/* 
# Create Invitation Links System
1. New Table: invitation_links
2. New Table: invitation_uses (tracking)
3. Add RLS policies
4. Create helper functions
*/

-- Create invitation_links table
CREATE TABLE IF NOT EXISTS invitation_links (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- Link Information
  invite_code text UNIQUE NOT NULL,
  invite_url text NOT NULL,
  
  -- Creator Information
  created_by uuid REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  creator_role text NOT NULL,
  
  -- Course Assignment
  course_id bigint REFERENCES courses(id) ON DELETE CASCADE NOT NULL,
  auto_enroll boolean DEFAULT true,
  
  -- Restrictions
  max_uses integer DEFAULT NULL,
  current_uses integer DEFAULT 0,
  valid_until timestamptz DEFAULT NULL,
  
  -- Email Restrictions
  allowed_emails text[] DEFAULT NULL,
  required_email_domain text,
  
  -- Status
  is_active boolean DEFAULT true,
  
  -- Metadata
  description text,
  custom_message text,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create invitation_uses table for tracking
CREATE TABLE IF NOT EXISTS invitation_uses (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  invitation_id bigint REFERENCES invitation_links(id) ON DELETE CASCADE NOT NULL,
  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE,
  
  email text NOT NULL,
  ip_address text,
  user_agent text,
  
  registration_completed boolean DEFAULT false,
  enrolled_in_course boolean DEFAULT false,
  
  created_at timestamptz DEFAULT now()
);

-- Indexes for invitation_links
CREATE INDEX IF NOT EXISTS idx_invitation_links_code ON invitation_links(invite_code);
CREATE INDEX IF NOT EXISTS idx_invitation_links_creator ON invitation_links(created_by);
CREATE INDEX IF NOT EXISTS idx_invitation_links_course ON invitation_links(course_id);
CREATE INDEX IF NOT EXISTS idx_invitation_links_active ON invitation_links(is_active) WHERE is_active = true;

-- Indexes for invitation_uses
CREATE INDEX IF NOT EXISTS idx_invitation_uses_invitation ON invitation_uses(invitation_id);
CREATE INDEX IF NOT EXISTS idx_invitation_uses_user ON invitation_uses(user_id);
CREATE INDEX IF NOT EXISTS idx_invitation_uses_email ON invitation_uses(email);

-- Enable RLS
ALTER TABLE invitation_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE invitation_uses ENABLE ROW LEVEL SECURITY;

-- RLS Policies for invitation_links

-- Public can view active invitations (for validation during signup)
CREATE POLICY "Public can view active invitations"
ON invitation_links FOR SELECT
USING (is_active = true);

-- Creators can view their own invitations
CREATE POLICY "Users can view own invitations"
ON invitation_links FOR SELECT TO authenticated
USING (
  created_by = auth.uid() OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Admins and approved tutors can create invitations
CREATE POLICY "Admins and tutors can create invitations"
ON invitation_links FOR INSERT TO authenticated
WITH CHECK (
  EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() 
    AND (
      role = 'admin' OR 
      (role = 'tutor' AND tutor_approved = true)
    )
  )
);

-- Creators can update their invitations
CREATE POLICY "Creators can update invitations"
ON invitation_links FOR UPDATE TO authenticated
USING (
  created_by = auth.uid() OR 
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Creators can delete their invitations
CREATE POLICY "Creators can delete invitations"
ON invitation_links FOR DELETE TO authenticated
USING (
  created_by = auth.uid() OR 
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
);

-- RLS Policies for invitation_uses

-- Creators can view uses of their invitations
CREATE POLICY "Creators can view invitation uses"
ON invitation_uses FOR SELECT TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM invitation_links il
    WHERE il.id = invitation_uses.invitation_id
    AND (il.created_by = auth.uid() OR EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'))
  )
);

-- System can insert invitation uses
CREATE POLICY "System can track invitation uses"
ON invitation_uses FOR INSERT
WITH CHECK (true);

-- Function to validate invitation link
CREATE OR REPLACE FUNCTION validate_invitation_link(p_invite_code text, p_email text DEFAULT NULL)
RETURNS TABLE (
  valid boolean,
  error_message text,
  invitation_id bigint,
  course_id bigint,
  course_name text,
  custom_message text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_invite invitation_links%ROWTYPE;
  v_course_name text;
  v_email_domain text;
BEGIN
  -- Get the invitation
  SELECT * INTO v_invite FROM invitation_links WHERE invite_code = p_invite_code;
  
  -- Check if invitation exists
  IF v_invite.id IS NULL THEN
    RETURN QUERY SELECT false, 'Invalid invitation link'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
    RETURN;
  END IF;
  
  -- Check if invitation is active
  IF v_invite.is_active = false THEN
    RETURN QUERY SELECT false, 'This invitation link has been deactivated'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
    RETURN;
  END IF;
  
  -- Check expiry
  IF v_invite.valid_until IS NOT NULL AND now() > v_invite.valid_until THEN
    RETURN QUERY SELECT false, 'This invitation link has expired'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
    RETURN;
  END IF;
  
  -- Check max uses
  IF v_invite.max_uses IS NOT NULL AND v_invite.current_uses >= v_invite.max_uses THEN
    RETURN QUERY SELECT false, 'This invitation link has reached its usage limit'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
    RETURN;
  END IF;
  
  -- Check email restrictions if email provided
  IF p_email IS NOT NULL THEN
    -- Check allowed emails list
    IF v_invite.allowed_emails IS NOT NULL AND NOT (p_email = ANY(v_invite.allowed_emails)) THEN
      RETURN QUERY SELECT false, 'Your email is not authorized to use this invitation'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
      RETURN;
    END IF;
    
    -- Check email domain restriction
    IF v_invite.required_email_domain IS NOT NULL THEN
      v_email_domain := substring(p_email from '@(.*)$');
      IF v_email_domain IS NULL OR v_email_domain != v_invite.required_email_domain THEN
        RETURN QUERY SELECT false, 'Your email domain is not authorized for this invitation'::text, NULL::bigint, NULL::bigint, NULL::text, NULL::text;
        RETURN;
      END IF;
    END IF;
  END IF;
  
  -- Get course name
  SELECT name INTO v_course_name FROM courses WHERE id = v_invite.course_id;
  
  -- Invitation is valid
  RETURN QUERY SELECT true, ''::text, v_invite.id, v_invite.course_id, v_course_name, v_invite.custom_message;
END;
$$;

-- Function to track invitation use
CREATE OR REPLACE FUNCTION track_invitation_use(
  p_invite_code text,
  p_email text,
  p_user_id uuid DEFAULT NULL,
  p_ip_address text DEFAULT NULL,
  p_user_agent text DEFAULT NULL
)
RETURNS TABLE (
  success boolean,
  error_message text,
  use_id bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_validation RECORD;
  v_new_use_id bigint;
BEGIN
  -- Validate the invitation
  SELECT * INTO v_validation FROM validate_invitation_link(p_invite_code, p_email);
  
  IF NOT v_validation.valid THEN
    RETURN QUERY SELECT false, v_validation.error_message, NULL::bigint;
    RETURN;
  END IF;
  
  -- Create invitation use record
  INSERT INTO invitation_uses (invitation_id, user_id, email, ip_address, user_agent)
  VALUES (v_validation.invitation_id, p_user_id, p_email, p_ip_address, p_user_agent)
  RETURNING id INTO v_new_use_id;
  
  -- Increment invitation usage count
  UPDATE invitation_links 
  SET current_uses = current_uses + 1,
      updated_at = now()
  WHERE id = v_validation.invitation_id;
  
  RETURN QUERY SELECT true, 'Invitation use tracked'::text, v_new_use_id;
END;
$$;

-- Function to complete invitation enrollment
CREATE OR REPLACE FUNCTION complete_invitation_enrollment(
  p_invite_code text,
  p_user_id uuid
)
RETURNS TABLE (
  success boolean,
  error_message text,
  enrollment_id bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_invite invitation_links%ROWTYPE;
  v_existing_enrollment bigint;
  v_new_enrollment_id bigint;
  v_user_email text;
BEGIN
  -- Get the invitation
  SELECT * INTO v_invite FROM invitation_links WHERE invite_code = p_invite_code AND is_active = true;
  
  IF v_invite.id IS NULL THEN
    RETURN QUERY SELECT false, 'Invalid or inactive invitation'::text, NULL::bigint;
    RETURN;
  END IF;
  
  -- Get user email
  SELECT email INTO v_user_email FROM profiles WHERE id = p_user_id;
  
  -- Check if auto-enroll is enabled
  IF v_invite.auto_enroll = false THEN
    RETURN QUERY SELECT false, 'Auto-enrollment is not enabled for this invitation'::text, NULL::bigint;
    RETURN;
  END IF;
  
  -- Check if already enrolled
  SELECT id INTO v_existing_enrollment 
  FROM enrollments 
  WHERE user_id = p_user_id AND course_id = v_invite.course_id;
  
  IF v_existing_enrollment IS NOT NULL THEN
    -- Update invitation use to mark enrollment completed
    UPDATE invitation_uses 
    SET registration_completed = true,
        enrolled_in_course = true
    WHERE invitation_id = v_invite.id AND user_id = p_user_id;
    
    RETURN QUERY SELECT true, 'Already enrolled'::text, v_existing_enrollment;
    RETURN;
  END IF;
  
  -- Create enrollment
  INSERT INTO enrollments (user_id, course_id, enrollment_method)
  VALUES (p_user_id, v_invite.course_id, 'invitation')
  RETURNING id INTO v_new_enrollment_id;
  
  -- Update invitation use to mark enrollment completed
  UPDATE invitation_uses 
  SET registration_completed = true,
      enrolled_in_course = true
  WHERE invitation_id = v_invite.id AND user_id = p_user_id;
  
  RETURN QUERY SELECT true, 'Successfully enrolled'::text, v_new_enrollment_id;
END;
$$;

-- Function to get invitation statistics
CREATE OR REPLACE FUNCTION get_invitation_stats(p_invitation_id bigint)
RETURNS TABLE (
  total_uses bigint,
  completed_registrations bigint,
  completed_enrollments bigint,
  pending_registrations bigint,
  recent_uses jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::bigint as total_uses,
    COUNT(*) FILTER (WHERE registration_completed = true)::bigint as completed_registrations,
    COUNT(*) FILTER (WHERE enrolled_in_course = true)::bigint as completed_enrollments,
    COUNT(*) FILTER (WHERE registration_completed = false)::bigint as pending_registrations,
    jsonb_agg(
      jsonb_build_object(
        'email', iu.email,
        'user_id', iu.user_id,
        'registered', iu.registration_completed,
        'enrolled', iu.enrolled_in_course,
        'created_at', iu.created_at
      ) ORDER BY iu.created_at DESC
    ) FILTER (WHERE iu.id IS NOT NULL) as recent_uses
  FROM invitation_uses iu
  WHERE iu.invitation_id = p_invitation_id;
END;
$$;
