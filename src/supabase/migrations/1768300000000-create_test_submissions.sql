/* 
# Create Advanced Grading System
1. Update questions table with section information
2. New Table: test_submissions (detailed grading)
3. New Table: grade_scales (scoring configuration)
4. Add RLS policies
5. Create scoring functions
*/

-- Update questions table with section information
DO $$ 
BEGIN 
    -- Add section identifier (math, reading, writing, general)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'questions' AND column_name = 'section') THEN
        ALTER TABLE questions ADD COLUMN section text DEFAULT 'general';
    END IF;

    -- Add difficulty weight for weighted scoring
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'questions' AND column_name = 'difficulty_weight') THEN
        ALTER TABLE questions ADD COLUMN difficulty_weight numeric(3, 2) DEFAULT 1.00;
    END IF;

    -- Add points value per question
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'questions' AND column_name = 'points') THEN
        ALTER TABLE questions ADD COLUMN points integer DEFAULT 1;
    END IF;
END $$;

-- Create indexes for section-based queries
CREATE INDEX IF NOT EXISTS idx_questions_section ON questions(section);
CREATE INDEX IF NOT EXISTS idx_questions_course_section ON questions(course_id, section);

-- Create test_submissions table
CREATE TABLE IF NOT EXISTS test_submissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- Student & Course
  user_id uuid REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  course_id bigint REFERENCES courses(id) ON DELETE CASCADE NOT NULL,
  level text NOT NULL,
  
  -- Test Metadata
  test_date timestamptz DEFAULT now(),
  test_duration_seconds integer,
  total_questions integer NOT NULL,
  
  -- Overall Scores
  raw_score integer NOT NULL,
  raw_score_percentage numeric(5, 2),
  scaled_score integer,
  
  -- Section Scores (Math)
  math_raw_score integer DEFAULT 0,
  math_total_questions integer DEFAULT 0,
  math_percentage numeric(5, 2),
  math_scaled_score integer,
  
  -- Section Scores (Reading)
  reading_raw_score integer DEFAULT 0,
  reading_total_questions integer DEFAULT 0,
  reading_percentage numeric(5, 2),
  reading_scaled_score integer,
  
  -- Section Scores (Writing)
  writing_raw_score integer DEFAULT 0,
  writing_total_questions integer DEFAULT 0,
  writing_percentage numeric(5, 2),
  writing_scaled_score integer,
  
  -- Analytics
  correct_questions bigint[] DEFAULT '{}',
  incorrect_questions bigint[] DEFAULT '{}',
  skipped_questions bigint[] DEFAULT '{}',
  
  -- Weak Areas Analysis
  weak_topics text[] DEFAULT '{}',
  strong_topics text[] DEFAULT '{}',
  
  -- Status
  is_completed boolean DEFAULT true,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Indexes for test_submissions
CREATE INDEX IF NOT EXISTS idx_test_submissions_user ON test_submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_test_submissions_course ON test_submissions(course_id);
CREATE INDEX IF NOT EXISTS idx_test_submissions_date ON test_submissions(test_date DESC);
CREATE INDEX IF NOT EXISTS idx_test_submissions_user_course ON test_submissions(user_id, course_id);

-- Enable RLS
ALTER TABLE test_submissions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for test_submissions

-- Users can view own submissions
CREATE POLICY "Users can view own test submissions"
ON test_submissions FOR SELECT TO authenticated
USING (user_id = auth.uid());

-- Users can insert own submissions
CREATE POLICY "Users can insert own test submissions"
ON test_submissions FOR INSERT TO authenticated
WITH CHECK (user_id = auth.uid());

-- Admins can view all submissions
CREATE POLICY "Admins can view all test submissions"
ON test_submissions FOR SELECT TO authenticated
USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Tutors can view their students' submissions
CREATE POLICY "Tutors can view student submissions"
ON test_submissions FOR SELECT TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM profiles p
    JOIN enrollments e ON e.user_id = test_submissions.user_id
    WHERE p.id = auth.uid()
    AND p.role = 'tutor'
    AND p.tutor_approved = true
    AND test_submissions.course_id = ANY(p.assigned_courses)
  )
);

-- Create grade_scales table for scoring configuration
CREATE TABLE IF NOT EXISTS grade_scales (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  course_id bigint REFERENCES courses(id) ON DELETE CASCADE,
  section text NOT NULL,
  
  -- Scoring Configuration
  min_raw_score integer NOT NULL,
  max_raw_score integer NOT NULL,
  min_scaled_score integer NOT NULL,
  max_scaled_score integer NOT NULL,
  
  -- Scale Type
  scale_type text DEFAULT 'linear',
  scale_config jsonb,
  
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now()
);

-- Indexes for grade_scales
CREATE INDEX IF NOT EXISTS idx_grade_scales_course ON grade_scales(course_id);
CREATE INDEX IF NOT EXISTS idx_grade_scales_section ON grade_scales(course_id, section);

-- Enable RLS
ALTER TABLE grade_scales ENABLE ROW LEVEL SECURITY;

-- RLS Policies for grade_scales

-- Everyone can view grade scales
CREATE POLICY "Anyone can view grade scales"
ON grade_scales FOR SELECT
USING (is_active = true);

-- Admins can manage grade scales
CREATE POLICY "Admins can manage grade scales"
ON grade_scales FOR ALL TO authenticated
USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'))
WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Function to calculate scaled score
CREATE OR REPLACE FUNCTION calculate_scaled_score(
  p_course_id bigint,
  p_section text,
  p_raw_score integer,
  p_total_questions integer
)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_scale grade_scales%ROWTYPE;
  v_percentage numeric;
  v_scaled_score integer;
BEGIN
  -- Get the grade scale for this course and section
  SELECT * INTO v_scale 
  FROM grade_scales 
  WHERE course_id = p_course_id 
    AND section = p_section 
    AND is_active = true
  LIMIT 1;
  
  -- If no scale found, return NULL
  IF v_scale.id IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Calculate percentage (0-1)
  IF p_total_questions = 0 THEN
    RETURN v_scale.min_scaled_score;
  END IF;
  
  v_percentage := p_raw_score::numeric / p_total_questions::numeric;
  
  -- Apply linear scaling
  IF v_scale.scale_type = 'linear' THEN
    v_scaled_score := ROUND(
      v_scale.min_scaled_score + 
      (v_percentage * (v_scale.max_scaled_score - v_scale.min_scaled_score))
    );
    
    -- Ensure score is within bounds
    v_scaled_score := GREATEST(v_scale.min_scaled_score, LEAST(v_scale.max_scaled_score, v_scaled_score));
    
    RETURN v_scaled_score;
  END IF;
  
  -- Default: return raw score if unknown scale type
  RETURN p_raw_score;
END;
$$;

-- Function to submit and grade a test
CREATE OR REPLACE FUNCTION submit_and_grade_test(
  p_user_id uuid,
  p_course_id bigint,
  p_level text,
  p_question_ids bigint[],
  p_answers text[],
  p_duration_seconds integer DEFAULT NULL
)
RETURNS TABLE (
  submission_id bigint,
  raw_score integer,
  raw_percentage numeric,
  scaled_score integer,
  section_scores jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_submission_id bigint;
  v_total_questions integer;
  v_raw_score integer := 0;
  v_raw_percentage numeric;
  v_scaled_score integer;
  
  v_math_correct integer := 0;
  v_math_total integer := 0;
  v_reading_correct integer := 0;
  v_reading_total integer := 0;
  v_writing_correct integer := 0;
  v_writing_total integer := 0;
  
  v_correct_ids bigint[] := '{}';
  v_incorrect_ids bigint[] := '{}';
  
  v_question record;
  v_answer text;
  v_index integer;
BEGIN
  v_total_questions := array_length(p_question_ids, 1);
  
  -- Grade each question
  FOR v_index IN 1..v_total_questions LOOP
    SELECT * INTO v_question 
    FROM questions 
    WHERE id = p_question_ids[v_index];
    
    v_answer := p_answers[v_index];
    
    -- Check if correct
    IF v_answer = v_question.correct_answer THEN
      v_raw_score := v_raw_score + 1;
      v_correct_ids := array_append(v_correct_ids, v_question.id);
      
      -- Count by section
      CASE v_question.section
        WHEN 'math' THEN
          v_math_correct := v_math_correct + 1;
          v_math_total := v_math_total + 1;
        WHEN 'reading' THEN
          v_reading_correct := v_reading_correct + 1;
          v_reading_total := v_reading_total + 1;
        WHEN 'writing' THEN
          v_writing_correct := v_writing_correct + 1;
          v_writing_total := v_writing_total + 1;
        ELSE
          -- General or unknown section
          NULL;
      END CASE;
    ELSE
      v_incorrect_ids := array_append(v_incorrect_ids, v_question.id);
      
      -- Still count total for section
      CASE v_question.section
        WHEN 'math' THEN
          v_math_total := v_math_total + 1;
        WHEN 'reading' THEN
          v_reading_total := v_reading_total + 1;
        WHEN 'writing' THEN
          v_writing_total := v_writing_total + 1;
        ELSE
          NULL;
      END CASE;
    END IF;
  END LOOP;
  
  -- Calculate percentage
  v_raw_percentage := (v_raw_score::numeric / v_total_questions::numeric) * 100;
  
  -- Calculate scaled scores
  v_scaled_score := calculate_scaled_score(p_course_id, 'overall', v_raw_score, v_total_questions);
  
  -- Insert submission
  INSERT INTO test_submissions (
    user_id, course_id, level,
    test_duration_seconds, total_questions,
    raw_score, raw_score_percentage, scaled_score,
    math_raw_score, math_total_questions, 
    math_percentage, math_scaled_score,
    reading_raw_score, reading_total_questions,
    reading_percentage, reading_scaled_score,
    writing_raw_score, writing_total_questions,
    writing_percentage, writing_scaled_score,
    correct_questions, incorrect_questions
  ) VALUES (
    p_user_id, p_course_id, p_level,
    p_duration_seconds, v_total_questions,
    v_raw_score, v_raw_percentage, v_scaled_score,
    v_math_correct, v_math_total,
    CASE WHEN v_math_total > 0 THEN (v_math_correct::numeric / v_math_total::numeric) * 100 ELSE 0 END,
    calculate_scaled_score(p_course_id, 'math', v_math_correct, v_math_total),
    v_reading_correct, v_reading_total,
    CASE WHEN v_reading_total > 0 THEN (v_reading_correct::numeric / v_reading_total::numeric) * 100 ELSE 0 END,
    calculate_scaled_score(p_course_id, 'reading', v_reading_correct, v_reading_total),
    v_writing_correct, v_writing_total,
    CASE WHEN v_writing_total > 0 THEN (v_writing_correct::numeric / v_writing_total::numeric) * 100 ELSE 0 END,
    calculate_scaled_score(p_course_id, 'writing', v_writing_correct, v_writing_total),
    v_correct_ids, v_incorrect_ids
  ) RETURNING id INTO v_submission_id;
  
  -- Return results
  RETURN QUERY
  SELECT 
    v_submission_id,
    v_raw_score,
    v_raw_percentage,
    v_scaled_score,
    jsonb_build_object(
      'math', jsonb_build_object(
        'correct', v_math_correct,
        'total', v_math_total,
        'percentage', CASE WHEN v_math_total > 0 THEN (v_math_correct::numeric / v_math_total::numeric) * 100 ELSE 0 END,
        'scaled_score', calculate_scaled_score(p_course_id, 'math', v_math_correct, v_math_total)
      ),
      'reading', jsonb_build_object(
        'correct', v_reading_correct,
        'total', v_reading_total,
        'percentage', CASE WHEN v_reading_total > 0 THEN (v_reading_correct::numeric / v_reading_total::numeric) * 100 ELSE 0 END,
        'scaled_score', calculate_scaled_score(p_course_id, 'reading', v_reading_correct, v_reading_total)
      ),
      'writing', jsonb_build_object(
        'correct', v_writing_correct,
        'total', v_writing_total,
        'percentage', CASE WHEN v_writing_total > 0 THEN (v_writing_correct::numeric / v_writing_total::numeric) * 100 ELSE 0 END,
        'scaled_score', calculate_scaled_score(p_course_id, 'writing', v_writing_correct, v_writing_total)
      )
    );
END;
$$;
